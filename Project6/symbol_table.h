#ifndef SYMBOL_TABLE_H
#define SYMBOL_TABLE_H

#include <cstdlib>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <sstream>
#include <vector>

#include "type_info.h"

// This file contains all of the information about the symbol table.
//
// symbolTable : interacted with by the rest of the code to look up variables.
// tableEntry : all of the stored information about a single variable.

class symbolTable;
class ASTNode;
class TC_Array;

class tableEntry {
  friend class symbolTable;
protected:
  int type_id;             // Type of this variable
  std::string name;        // Variable name used in input sourcecode.
  bool is_temp;            // Is this variable just temporary (generated by compiler)?
  int var_id;              // What is the intermediate code ID for this variable?
  int array_id;            // If this variable is an array index, which array?
  tableEntry * array_ptr;
  int index_id;            // If this variable is an array index, which index?
  int scope;               // What scope was this variable created at?
  tableEntry * next;       // Pointer to another variable this one is shadowing.

  tableEntry(int in_type)
    : type_id (in_type)
    , name("__TEMP__")
    , is_temp(true)
    , var_id(-1)
    , array_id(-1)
    , array_ptr(NULL)
    , index_id(-1)
    , scope(-1)
    , next(NULL)
  {
  }

  tableEntry(int in_type, const std::string in_name)
    : type_id(in_type)
    , name(in_name)
    , is_temp(false)
    , var_id(-1)
    , array_id(-1)
    , array_ptr(NULL)
    , index_id(-1)
  {
  }
  virtual ~tableEntry() { ; }

public:
  // Accessors for member information.
  int GetType()          const { return type_id; }
  std::string GetName()  const { return name; }
  bool GetTemp()         const { return is_temp; }
  int GetVarID()         const { return var_id; }
  int GetArrayID()       const { return array_id; }
  tableEntry * GetArrayPtr()   { return array_ptr; }
  int GetIndexID()       const { return index_id; }
  int GetScope()         const { return scope; }
  tableEntry * GetNext() const { return next; }

  void SetName(std::string in_name) { name = in_name; }
  void SetVarID(int in_id) { var_id = in_id; }
  void SetArrayIndex(int a, tableEntry * _ptr, int i) {
    array_id = a; array_ptr = _ptr; index_id = i;
  }
  void SetScope(int in_scope) { scope = in_scope; }
  void SetNext(tableEntry * in_next) { next = in_next; }

  // Quick type determination
  bool IsArray() { return Type::IsArray(type_id); }
  bool IsScalar() { return Type::IsScalar(type_id); }
};


class symbolTable {
private:
  std::map<std::string, tableEntry *> tbl_map;
  std::vector<std::vector<tableEntry *> *> scope_info;
  std::vector<tableEntry *> var_archive;
  int cur_scope;
  int next_var_id;                            // Next variable ID to use.
  int next_label_id;                          // Next label ID to use.
  std::set<int> temp_svar_ids;                // Which variables are active temporaries?
  std::set<int> temp_avar_ids;                // Which variables are active temporaries?
  std::vector<std::string> while_start_stack; // Start labels for while commands, in case of continue
  std::vector<std::string> while_end_stack;   // End labels for while commands, in case of break

  // Figure out the next memory position to use.  Ideally, we should be
  // recycling these!!
  int GetNextID() { return next_var_id++; }
public:
  symbolTable() : cur_scope(0), next_var_id(1), next_label_id(0) {
    scope_info.push_back(new std::vector<tableEntry *>);
  }
  ~symbolTable() {
    while (cur_scope >= 0) DecScope();
    for (int i = 0; i < (int) var_archive.size(); i++) delete var_archive[i];
  }

  int GetSize() { return tbl_map.size(); } // Note: ignores shadowed variables!
  int GetCurScope() { return cur_scope; }
  const std::vector<tableEntry *> & GetScopeVars(int scope) {
    if (scope < 0 || scope >= (int) scope_info.size()) {
      std::cerr << "Internal Compiler Error: Requesting vars from scope #" << scope
           << ", but only " << scope_info.size() << " scopes exist." << std::endl;
    }
    return *(scope_info[scope]);
  }

  const std::set<int> & GetTempScalars() { return temp_svar_ids; }
  const std::set<int> & GetTempArrays() { return temp_avar_ids; }

  int GetNumVars() { return next_var_id; }

  void IncScope() {
    scope_info.push_back(new std::vector<tableEntry *>);
    cur_scope++;
  }
  void DecScope() {
    // Remove variables in the old scope and store them in the archive.
    std::vector<tableEntry *> * old_scope = scope_info.back();
    scope_info.pop_back();
    var_archive.insert(var_archive.end(), old_scope->begin(), old_scope->end());

    // Make sure to clean up the tbl_map.
    for (int i = 0; i < (int) old_scope->size(); i++) {
      tableEntry * old_entry = (*old_scope)[i];

      // If this entry is shadowing another, return to shadowed version.
      if (old_entry->GetNext() != NULL) {
        tbl_map[old_entry->GetName()] = old_entry->GetNext();
      }

      // Otherwise just remove it from the map.
      else {
        tbl_map.erase(old_entry->GetName());
      }
    }

    delete old_scope;
    cur_scope--;
  }

  int NextLabelID() { return next_label_id++; }
  std::string NextLabelID(std::string prefix) {
    std::stringstream sstm;
    sstm << prefix << next_label_id++;
    return sstm.str();
  }

  int NextArCopyID() { return next_label_id++; }
  // flag name: "ar_do_copy_", "ar_copy_start_", "ar_copy_end_"
  std::string NextArCopyID(std::string prefix) {
    if (prefix == "ar_do_copy_") {
      std::stringstream sstm;
      sstm << prefix << next_label_id++;
      return sstm.str();
    }
    else if (prefix == "ar_copy_start_") {
      std::stringstream sstm;
      sstm << prefix << next_label_id++;
      return sstm.str();
    }

    else if (prefix == "ar_copy_end_") {
      std::stringstream sstm;
      sstm << prefix << next_label_id++;
      return sstm.str();
    }
    else { return "-1"; }
  }

  int NextArResizeID() { return next_label_id++; }
  // flag name: "ar_resize_do_copy_", "ar_resize_start_", "ar_resize_end_"
  std::string NextArResizeID(std::string prefix) {
    if (prefix == "ar_resize_do_copy_") {
      std::stringstream sstm;
      sstm << prefix << next_label_id++;
      return sstm.str();
    }
    else if (prefix == "ar_resize_start_") {
      std::stringstream sstm;
      sstm << prefix << next_label_id++;
      return sstm.str();
    }

    else if (prefix == "ar_resize_end_") {
      std::stringstream sstm;
      sstm << prefix << next_label_id++;
      return sstm.str();
    }
    else { return "-1"; }
  }

  int GetWhileDepth() { return (int) while_end_stack.size(); }
  void PushWhileStartLabel(const std::string & start_label) { while_start_stack.push_back(start_label); }
  void PushWhileEndLabel(const std::string & end_label) { while_end_stack.push_back(end_label); }
  const std::string & GetWhileStartLabel() { return while_start_stack.back(); }
  const std::string & GetWhileEndLabel() { return while_end_stack.back(); }
  void PopWhileStartLabel() { while_start_stack.pop_back(); }
  void PopWhileEndLabel() { while_end_stack.pop_back(); }

  // Lookup will find an entry and return it.  If that entry is not in the table, it will return NULL
  tableEntry * Lookup(std::string in_name) {
    if (tbl_map.find(in_name) == tbl_map.end()) return NULL;
    return tbl_map[in_name];
  }

  // Determine if a variable has been declared in the current scope.
  bool InCurScope(std::string in_name) {
    if (tbl_map.find(in_name) == tbl_map.end()) return false;
    return tbl_map[in_name]->GetScope() == cur_scope;
  }

  // Insert an entry into the symbol table.
  tableEntry * AddEntry(int in_type, std::string in_name) {
    // Create the new symbol table entry.
    tableEntry * new_entry = new tableEntry(in_type, in_name);
    new_entry->SetVarID( GetNextID() );
    new_entry->SetScope(cur_scope);

    // If an old entry exists, shadow it.
    tableEntry * old_entry = Lookup(in_name);
    if (old_entry) new_entry->SetNext(old_entry);

    // Save info for the new entry.
    tbl_map[in_name] = new_entry;
    scope_info[cur_scope]->push_back(new_entry);
    return new_entry;
  }

  // Quick method to build a new temporary symbol table entry with just type and var_id
  tableEntry * BuildTempEntry(int type_id, int var_id) {
    tableEntry * new_entry = new tableEntry(type_id);
    new_entry->SetVarID(var_id);
    return new_entry;
  }

  // Don't create a full variable; just get an unused variable ID.
  tableEntry * GetTempVar(int type_id) {
    const int id=GetNextID();
    tableEntry * new_entry = BuildTempEntry(type_id, id);

    // Track the temporary ids in use.
    if (Type::IsArray(type_id)) temp_avar_ids.insert(id);
    else temp_svar_ids.insert(id);

    // Return this entry.
    return new_entry;
  }
  void FreeTempVar(tableEntry * temp_var) {
    temp_avar_ids.erase(temp_var->GetVarID());
    temp_svar_ids.erase(temp_var->GetVarID());
    delete temp_var;
  }

  void RemoveEntry(tableEntry * del_var) {
    if (del_var->GetTemp()) FreeTempVar(del_var);
    else delete del_var;
  }

  void Debug() {
    std::cerr << "Temp IDs:";
    for (std::set<int>::iterator it=temp_avar_ids.begin(); it != temp_avar_ids.end(); ++it) {
      std::cerr << " a" << *it;
    }
    for (std::set<int>::iterator it=temp_svar_ids.begin(); it != temp_svar_ids.end(); ++it) {
      std::cerr << " s" << *it;
    }
    std::cerr << std::endl;
  }
};

#endif
